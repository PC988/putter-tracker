<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Putter Swing Tracker</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding-top: 20px;
    }

    /* Whole app container so we can flip UI */
    #app {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      transform-origin: center center;
    }

    /* When UI is flipped, rotate the whole app 180° */
    body.ui-flipped #app {
      transform: rotate(180deg);
    }

    h1 {
      margin: 0 0 5px;
      font-size: 18px;
      text-align: center;
    }

    p {
      margin: 0;
      font-size: 12px;
      text-align: center;
      max-width: 600px;
      opacity: 0.8;
    }

    #videoWrapper {
      position: relative;
      width: 90vw;
      max-width: 800px;
      aspect-ratio: 16 / 9;
      border: 2px solid #fff;
      border-radius: 8px;
      overflow: hidden;
      background: #111;
      transform-origin: center center;
    }

    /* Counter-rotate the camera box so it stays normal
       even when the UI is flipped */
    body.ui-flipped #videoWrapper {
      transform: rotate(180deg);
    }

    video,
    canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    canvas {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: auto; /* allow dragging events on overlay */
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
      align-items: center;
    }

    button {
      padding: 8px 14px;
      border-radius: 6px;
      border: none;
      font-size: 14px;
      cursor: pointer;
    }

    label {
      font-size: 12px;
    }

    select {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
      color: #fff;
      font-size: 12px;
    }

    #angleDisplay {
      font-size: 14px;
      margin-top: 4px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1>Putter Swing Tracker</h1>
    <p>
      Put a bright <b>blue</b> sticker on the putter head and a bright <b>red</b> sticker higher on the shaft or grip.<br>
      The app draws the blue head path, shows live angle, and locks a contact angle when the head gets close to the vertical contact line.
      Drag the cyan line left/right to set your contact line.
    </p>

    <div id="videoWrapper">
      <video id="video" autoplay playsinline></video>
      <canvas id="overlay"></canvas>
    </div>

    <div id="controls">
      <button id="startBtn">Start Camera</button>
      <button id="clearBtn">Clear Path</button>
      <button id="pauseBtn">Stop</button>
      <button id="flipBtn">Flip UI</button>
      <button id="zeroBtn">Zero Angle</button>

      <label for="autoClearSelect">
        Auto-clear:
        <select id="autoClearSelect">
          <option value="0">Off</option>
          <option value="3">Every 3s</option>
          <option value="5">Every 5s</option>
          <option value="10">Every 10s</option>
        </select>
      </label>
    </div>

    <div id="angleDisplay">
      Live angle: <span id="liveAngle">—</span><br>
      Contact angle: <span id="contactAngle">—</span>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const clearBtn = document.getElementById('clearBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const flipBtn = document.getElementById('flipBtn');
    const zeroBtn = document.getElementById('zeroBtn');
    const autoClearSelect = document.getElementById('autoClearSelect');
    const liveAngleEl = document.getElementById('liveAngle');
    const contactAngleEl = document.getElementById('contactAngle');

    // Hidden canvas for pixel processing
    const hiddenCanvas = document.createElement('canvas');
    const hctx = hiddenCanvas.getContext('2d');

    // Stores path points (blue head)
    let pathPoints = [];
    let tracking = false;        // controls whether frames are processed
    let hasLoopStarted = false;  // ensure RAF loop only started once

    // Auto-clear interval ID
    let autoClearIntervalId = null;

    // For angle calculation
    let baselineAngle = null;    // angle at "zero"
    let lastAngleDeg = null;     // most recent raw angle
    let contactAngleDeg = null;  // locked-in contact angle

    // Contact line (vertical)
    let contactLineX = null;

    // Dragging the contact line
    let draggingLine = false;
    const LINE_HIT_RADIUS = 40;  // px threshold for grabbing the line

    // Distance-based contact detection
    let lastContactTime = 0;
    const CONTACT_DISTANCE_PX = 12;      // how close blue must be to the line
    const CONTACT_COOLDOWN_MS = 400;     // min time between contact updates (ms)

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false
        });
        video.srcObject = stream;

        video.addEventListener('loadedmetadata', () => {
          const width = video.videoWidth;
          const height = video.videoHeight;

          overlay.width = width;
          overlay.height = height;
          hiddenCanvas.width = width;
          hiddenCanvas.height = height;

          // Start with contact line in the middle
          contactLineX = width * 0.5;

          tracking = true;
          pauseBtn.textContent = "Stop";

          if (!hasLoopStarted) {
            hasLoopStarted = true;
            requestAnimationFrame(processFrame);
          }
        }, { once: true });

      } catch (err) {
        console.error(err);
        alert("Could not access camera: " + err.message);
      }
    }

    function clearPath() {
      pathPoints = [];
      octx.clearRect(0, 0, overlay.width, overlay.height);
    }

    function setAutoClearInterval() {
      if (autoClearIntervalId !== null) {
        clearInterval(autoClearIntervalId);
        autoClearIntervalId = null;
      }

      const seconds = parseInt(autoClearSelect.value, 10);
      if (seconds > 0) {
        autoClearIntervalId = setInterval(() => {
          clearPath();
        }, seconds * 1000);
      }
    }

    function toggleFlip() {
      document.body.classList.toggle('ui-flipped');
    }

    function togglePause() {
      tracking = !tracking;
      pauseBtn.textContent = tracking ? "Stop" : "Continue";
    }

    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, v = max;
      const d = max - min;
      s = max === 0 ? 0 : d / max;

      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return { h: h * 360, s, v };
    }

    function normalizeAngle(angleDeg) {
      let a = angleDeg;
      while (a > 180) a -= 360;
      while (a < -180) a += 360;
      return a;
    }

    function processFrame() {
      if (!hasLoopStarted) return;

      requestAnimationFrame(processFrame);

      if (!tracking || video.readyState !== 4) {
        return;
      }

      const w = hiddenCanvas.width;
      const h = hiddenCanvas.height;

      hctx.drawImage(video, 0, 0, w, h);
      const frame = hctx.getImageData(0, 0, w, h);
      const data = frame.data;

      let sumXBlue = 0, sumYBlue = 0, countBlue = 0;
      let sumXRed = 0, sumYRed = 0, countRed = 0;

      // Dense pixel scan for recognition
      const step = 4 * 1;
      for (let i = 0; i < data.length; i += step) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        const hsv = rgbToHsv(r, g, b);

        // BLUE (head) – stricter so it only locks on the sticker
        const isBlue =
          hsv.h > 190 && hsv.h < 250 &&  // narrower blue band
          hsv.s > 0.45 &&                // fairly saturated
          hsv.v > 0.30;                  // not too dark

        // RED (top) – strong red, but a bit forgiving
        const isRedBase =
          (hsv.h < 20 || hsv.h > 340) && // red band, not orange
          hsv.s > 0.5 &&                 // saturated
          hsv.v > 0.35;                  // not super dark

        const pixelIndex = i / 4;
        const x = pixelIndex % w;
        const y = Math.floor(pixelIndex / w);

        if (isBlue) {
          sumXBlue += x;
          sumYBlue += y;
          countBlue++;
        }

        if (isRedBase) {
          sumXRed += x;
          sumYRed += y;
          countRed++;
        }
      }

      // Clear overlay
      octx.clearRect(0, 0, overlay.width, overlay.height);

      // Draw vertical contact line
      if (contactLineX !== null) {
        octx.save();
        octx.strokeStyle = "rgba(0, 255, 255, 0.7)";
        octx.lineWidth = 2;
        octx.setLineDash([10, 6]);
        octx.beginPath();
        octx.moveTo(contactLineX, 0);
        octx.lineTo(contactLineX, overlay.height);
        octx.stroke();
        octx.setLineDash([]);
        octx.fillStyle = "rgba(0, 255, 255, 0.7)";
        octx.font = "14px sans-serif";
        octx.textAlign = "center";
        octx.fillText("Contact line", contactLineX, 16);
        octx.restore();
      }

      let blueCenter = null;
      let rawRedCenter = null;
      let redCenter = null;

      // BLUE center (head)
      if (countBlue > 0) {
        const cxB = sumXBlue / countBlue;
        const cyB = sumYBlue / countBlue;
        blueCenter = { x: cxB, y: cyB };

        // Add to path only when visible
        pathPoints.push({ x: cxB, y: cyB });
        if (pathPoints.length > 1500) {
          pathPoints.shift();
        }
      }

      // Draw path ALWAYS so it persists when club leaves frame
      if (pathPoints.length > 1) {
        octx.beginPath();
        octx.lineWidth = 4;
        octx.strokeStyle = "lime";
        octx.moveTo(pathPoints[0].x, pathPoints[0].y);
        for (let i = 1; i < pathPoints.length; i++) {
          octx.lineTo(pathPoints[i].x, pathPoints[i].y);
        }
        octx.stroke();
      }

      // Draw blue marker
      if (blueCenter) {
        octx.beginPath();
        octx.arc(blueCenter.x, blueCenter.y, 8, 0, Math.PI * 2);
        octx.fillStyle = "deepskyblue";
        octx.fill();
      }

      // RED center (raw, before filters)
      if (countRed > 0) {
        const cxR = sumXRed / countRed;
        const cyR = sumYRed / countRed;
        rawRedCenter = { x: cxR, y: cyR };
      }

      // Filter red by area (ignore tiny noise and huge blobs like feet)
      if (countRed > 10 && countRed < 10000 && rawRedCenter) {
        redCenter = { ...rawRedCenter };
      }

      // Further filter red position relative to blue (assuming red is above head on shaft)
      if (redCenter && blueCenter) {
        const dx = redCenter.x - blueCenter.x;
        const dy = redCenter.y - blueCenter.y; // negative if red is above

        // Fairly forgiving; adjust if needed
        if (Math.abs(dx) > 220 || dy > 80 || dy < -500) {
          redCenter = null;
        }
      }

      // Draw red marker (after filters)
      if (redCenter) {
        octx.beginPath();
        octx.arc(redCenter.x, redCenter.y, 8, 0, Math.PI * 2);
        octx.fillStyle = "red";
        octx.fill();
      }

      // Angle + contact-angle logic
      if (blueCenter && redCenter) {
        // Line blue -> red
        octx.beginPath();
        octx.moveTo(blueCenter.x, blueCenter.y);
        octx.lineTo(redCenter.x, redCenter.y);
        octx.lineWidth = 3;
        octx.strokeStyle = "yellow";
        octx.stroke();

        const dx = redCenter.x - blueCenter.x;
        const dy = redCenter.y - blueCenter.y;
        let angleRad = Math.atan2(dy, dx);
        let angleDeg = angleRad * 180 / Math.PI;
        angleDeg = normalizeAngle(angleDeg);
        lastAngleDeg = angleDeg;

        let displayAngle = angleDeg;
        if (baselineAngle !== null) {
          displayAngle = normalizeAngle(angleDeg - baselineAngle);
        }
        liveAngleEl.textContent = displayAngle.toFixed(1) + "°";

        // ---- distance-based contact detection ----
        if (contactLineX !== null && blueCenter) {
          const dist = Math.abs(blueCenter.x - contactLineX);
          const now = performance.now();

          if (dist < CONTACT_DISTANCE_PX && (now - lastContactTime) > CONTACT_COOLDOWN_MS) {
            contactAngleDeg = displayAngle;
            contactAngleEl.textContent = contactAngleDeg.toFixed(1) + "°";
            lastContactTime = now;
          }
        }
      }
      // If we don't see both markers, we keep previous contact angle.
    }

    function zeroAngle() {
      if (lastAngleDeg !== null) {
        baselineAngle = lastAngleDeg;
      }
    }

    // ---- Dragging the vertical contact line ----
    function canvasPointFromEvent(e) {
      const rect = overlay.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (overlay.width / rect.width);
      const y = (e.clientY - rect.top) * (overlay.height / rect.height);
      return { x, y };
    }

    function onPointerDown(e) {
      const { x } = canvasPointFromEvent(e);
      if (contactLineX !== null && Math.abs(x - contactLineX) <= LINE_HIT_RADIUS) {
        draggingLine = true;
        e.preventDefault();
      }
    }

    function onPointerMove(e) {
      if (!draggingLine) return;
      const { x } = canvasPointFromEvent(e);
      contactLineX = Math.max(0, Math.min(overlay.width, x));
      e.preventDefault();
    }

    function onPointerUp(e) {
      draggingLine = false;
    }

    // pointer events
    overlay.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('pointercancel', onPointerUp);

    startBtn.addEventListener('click', startCamera);
    clearBtn.addEventListener('click', clearPath);
    pauseBtn.addEventListener('click', togglePause);
    flipBtn.addEventListener('click', toggleFlip);
    zeroBtn.addEventListener('click', zeroAngle);
    autoClearSelect.addEventListener('change', setAutoClearInterval);
  </script>
</body>
</html>
