<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Putter Swing Tracker</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding-top: 20px;
    }

    /* Whole app container so we can flip UI */
    #app {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      transform-origin: center center;
    }

    /* When UI is flipped, rotate the whole app 180° */
    body.ui-flipped #app {
      transform: rotate(180deg);
    }

    h1 {
      margin: 0 0 5px;
      font-size: 18px;
      text-align: center;
    }

    p {
      margin: 0;
      font-size: 12px;
      text-align: center;
      max-width: 600px;
      opacity: 0.8;
    }

    #videoWrapper {
      position: relative;
      width: 90vw;
      max-width: 800px;
      aspect-ratio: 16 / 9;
      border: 2px solid #fff;
      border-radius: 8px;
      overflow: hidden;
      background: #111;
      transform-origin: center center;
    }

    /* Counter-rotate the camera box so it stays normal
       even when the UI is flipped */
    body.ui-flipped #videoWrapper {
      transform: rotate(180deg);
    }

    video,
    canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    canvas {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
      align-items: center;
    }

    button {
      padding: 8px 14px;
      border-radius: 6px;
      border: none;
      font-size: 14px;
      cursor: pointer;
    }

    label {
      font-size: 12px;
    }

    select {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
      color: #fff;
      font-size: 12px;
    }

    #angleDisplay {
      font-size: 14px;
      margin-top: 4px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1>Putter Swing Tracker</h1>
    <p>
      Put a bright <b>blue</b> sticker on the putter head and a bright <b>red</b> sticker higher on the shaft or grip.<br>
      The app draws the blue head path, shows live angle, and locks a contact angle when the head crosses the contact line.
    </p>

    <div id="videoWrapper">
      <video id="video" autoplay playsinline></video>
      <canvas id="overlay"></canvas>
    </div>

    <div id="controls">
      <button id="startBtn">Start Camera</button>
      <button id="clearBtn">Clear Path</button>
      <button id="pauseBtn">Stop</button>
      <button id="flipBtn">Flip UI</button>
      <button id="zeroBtn">Zero Angle</button>

      <label for="autoClearSelect">
        Auto-clear:
        <select id="autoClearSelect">
          <option value="0">Off</option>
          <option value="3">Every 3s</option>
          <option value="5">Every 5s</option>
          <option value="10">Every 10s</option>
        </select>
      </label>
    </div>

    <div id="angleDisplay">
      Live angle: <span id="liveAngle">—</span><br>
      Contact angle: <span id="contactAngle">—</span>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const clearBtn = document.getElementById('clearBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const flipBtn = document.getElementById('flipBtn');
    const zeroBtn = document.getElementById('zeroBtn');
    const autoClearSelect = document.getElementById('autoClearSelect');
    const liveAngleEl = document.getElementById('liveAngle');
    const contactAngleEl = document.getElementById('contactAngle');

    // Hidden canvas for pixel processing
    const hiddenCanvas = document.createElement('canvas');
    const hctx = hiddenCanvas.getContext('2d');

    // Stores path points (blue head)
    let pathPoints = [];
    let tracking = false;        // controls whether frames are processed
    let hasLoopStarted = false;  // ensure RAF loop only started once

    // Auto-clear interval ID
    let autoClearIntervalId = null;

    // For angle calculation
    let baselineAngle = null;    // angle at "zero"
    let lastAngleDeg = null;     // most recent raw angle
    let contactAngleDeg = null;  // locked-in contact angle

    // Contact line
    let contactLineY = null;
    let prevBlueY = null;        // previous blue Y position for crossing detection

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false
        });
        video.srcObject = stream;

        video.addEventListener('loadedmetadata', () => {
          const width = video.videoWidth;
          const height = video.videoHeight;

          overlay.width = width;
          overlay.height = height;
          hiddenCanvas.width = width;
          hiddenCanvas.height = height;

          // Place contact line at ~60% down the frame (tweak if you want)
          contactLineY = height * 0.6;

          tracking = true;
          pauseBtn.textContent = "Stop";

          if (!hasLoopStarted) {
            hasLoopStarted = true;
            requestAnimationFrame(processFrame);
          }
        }, { once: true });

      } catch (err) {
        console.error(err);
        alert("Could not access camera: " + err.message);
      }
    }

    function clearPath() {
      pathPoints = [];
      octx.clearRect(0, 0, overlay.width, overlay.height);
    }

    function setAutoClearInterval() {
      // Clear any existing interval
      if (autoClearIntervalId !== null) {
        clearInterval(autoClearIntervalId);
        autoClearIntervalId = null;
      }

      const seconds = parseInt(autoClearSelect.value, 10);
      if (seconds > 0) {
        autoClearIntervalId = setInterval(() => {
          clearPath();
        }, seconds * 1000);
      }
    }

    // Flip only the UI (camera box is counter-rotated in CSS)
    function toggleFlip() {
      document.body.classList.toggle('ui-flipped');
    }

    // Pause / resume tracking (camera keeps running)
    function togglePause() {
      tracking = !tracking;
      pauseBtn.textContent = tracking ? "Stop" : "Continue";
    }

    // Convert RGB to HSV
    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, v = max;
      const d = max - min;
      s = max === 0 ? 0 : d / max;

      if (max === min) {
        h = 0; // achromatic
      } else {
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return { h: h * 360, s, v };
    }

    function normalizeAngle(angleDeg) {
      // Bring angle into -180 .. 180 range
      let a = angleDeg;
      while (a > 180) a -= 360;
      while (a < -180) a += 360;
      return a;
    }

    function processFrame() {
      if (!hasLoopStarted) return;

      if (!tracking || video.readyState !== 4) {
        requestAnimationFrame(processFrame);
        return;
      }

      const w = hiddenCanvas.width;
      const h = hiddenCanvas.height;

      // Draw current frame to hidden canvas
      hctx.drawImage(video, 0, 0, w, h);
      const frame = hctx.getImageData(0, 0, w, h);
      const data = frame.data;

      let sumXBlue = 0, sumYBlue = 0, countBlue = 0;
      let sumXRed = 0, sumYRed = 0, countRed = 0;

      // Loop through pixels (denser sampling for faster recognition)
      const step = 4 * 1; // RGBA * skip 1 pixel (highest accuracy)
      for (let i = 0; i < data.length; i += step) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        const hsv = rgbToHsv(r, g, b);

        // ---- Color filter for BLUE (head) ----
        // Blue ~ hue around 180–260, quite saturated & bright
        const isBlue =
          hsv.h > 180 && hsv.h < 260 &&
          hsv.s > 0.45 &&
          hsv.v > 0.3;

        // ---- Color filter for RED (top) ----
        // Red ~ near 0 or 360, saturated, bright
        const isRed =
          (hsv.h < 25 || hsv.h > 335) &&
          hsv.s > 0.5 &&
          hsv.v > 0.3;

        const pixelIndex = i / 4;
        const x = pixelIndex % w;
        const y = Math.floor(pixelIndex / w);

        if (isBlue) {
          sumXBlue += x;
          sumYBlue += y;
          countBlue++;
        }

        if (isRed) {
          sumXRed += x;
          sumYRed += y;
          countRed++;
        }
      }

      // Clear overlay before drawing new frame
      octx.clearRect(0, 0, overlay.width, overlay.height);

      // Draw the contact line (semi-transparent)
      if (contactLineY !== null) {
        octx.save();
        octx.strokeStyle = "rgba(0, 255, 255, 0.7)";
        octx.lineWidth = 2;
        octx.setLineDash([10, 6]);
        octx.beginPath();
        octx.moveTo(0, contactLineY);
        octx.lineTo(overlay.width, contactLineY);
        octx.stroke();
        octx.setLineDash([]);
        octx.fillStyle = "rgba(0, 255, 255, 0.7)";
        octx.font = "14px sans-serif";
        octx.textAlign = "right";
        octx.fillText("Contact line", overlay.width - 10, contactLineY - 8);
        octx.restore();
      }

      let blueCenter = null;
      let redCenter = null;

      // Handle blue center (putter head)
      if (countBlue > 0) {
        const cxB = sumXBlue / countBlue;
        const cyB = sumYBlue / countBlue;
        blueCenter = { x: cxB, y: cyB };

        // Add to path (only when blue is seen)
        pathPoints.push({ x: cxB, y: cyB });
        if (pathPoints.length > 1500) {
          pathPoints.shift();
        }
      } else {
        // Lost blue tracking this frame
        blueCenter = null;
      }

      // ---- Draw path ALWAYS so it doesn't disappear when club is off-screen ----
      if (pathPoints.length > 1) {
        octx.beginPath();
        octx.lineWidth = 4;
        octx.strokeStyle = "lime";
        octx.moveTo(pathPoints[0].x, pathPoints[0].y);
        for (let i = 1; i < pathPoints.length; i++) {
          octx.lineTo(pathPoints[i].x, pathPoints[i].y);
        }
        octx.stroke();
      }

      // Draw blue marker if visible
      if (blueCenter) {
        octx.beginPath();
        octx.arc(blueCenter.x, blueCenter.y, 8, 0, Math.PI * 2);
        octx.fillStyle = "deepskyblue";
        octx.fill();
      }

      // Handle red center (top of shaft)
      if (countRed > 0) {
        const cxR = sumXRed / countRed;
        const cyR = sumYRed / countRed;
        redCenter = { x: cxR, y: cyR };

        // Draw red marker
        octx.beginPath();
        octx.arc(cxR, cyR, 8, 0, Math.PI * 2);
        octx.fillStyle = "red";
        octx.fill();
      }

      // If we have both markers, compute angle and draw line between them
      if (blueCenter && redCenter) {
        // Draw line between blue and red
        octx.beginPath();
        octx.moveTo(blueCenter.x, blueCenter.y);
        octx.lineTo(redCenter.x, redCenter.y);
        octx.lineWidth = 3;
        octx.strokeStyle = "yellow";
        octx.stroke();

        // Angle from blue (head) to red (top)
        const dx = redCenter.x - blueCenter.x;
        const dy = redCenter.y - blueCenter.y;
        let angleRad = Math.atan2(dy, dx);
        let angleDeg = angleRad * 180 / Math.PI;
        angleDeg = normalizeAngle(angleDeg);
        lastAngleDeg = angleDeg;

        let displayAngle = angleDeg;
        if (baselineAngle !== null) {
          displayAngle = normalizeAngle(angleDeg - baselineAngle);
        }

        liveAngleEl.textContent = displayAngle.toFixed(1) + "°";

        // --- Detect crossing of contact line to lock contact angle ---
        if (contactLineY !== null) {
          if (prevBlueY !== null) {
            const prevSide = prevBlueY - contactLineY;
            const currSide = blueCenter.y - contactLineY;

            // Different signs -> crossed the line, and not just tiny jitter near it
            if (prevSide * currSide < 0 && Math.abs(prevSide) > 5 && Math.abs(currSide) > 5) {
              contactAngleDeg = displayAngle;
              contactAngleEl.textContent = contactAngleDeg.toFixed(1) + "°";
            }
          }
          prevBlueY = blueCenter.y;
        }
      } else {
        // If we can't see both, still keep previous live angle text,
        // but reset prevBlueY so we don't trigger fake crossings later.
        prevBlueY = null;
      }

      requestAnimationFrame(processFrame);
    }

    function zeroAngle() {
      if (lastAngleDeg !== null) {
        baselineAngle = lastAngleDeg;
      }
    }

    startBtn.addEventListener('click', startCamera);
    clearBtn.addEventListener('click', clearPath);
    pauseBtn.addEventListener('click', togglePause);
    flipBtn.addEventListener('click', toggleFlip);
    zeroBtn.addEventListener('click', zeroAngle);
    autoClearSelect.addEventListener('change', setAutoClearInterval);
  </script>
</body>
</html>
